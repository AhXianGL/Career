# `!尚未完成!`思考函数式组件的优势(相对类组件而言)

> 函数式组件与类组件究竟哪里不同? 函数式组件的出现帮助开发者解决了什么问题?
> 这是我从入职前端开始用react,查看React文档后看到了RFC RCC两种组件的写法就思考的问题,
> 网上的那些浅尝辄止的回答,并不能满足我的好奇心

## `副作用`概念的显式引入

1. **webgis地图应用的前端实践,即React Flux架构下的应用状态与第三方库的副作用的复杂同步的场景下**。
   这种场景是将React的状态变更和对应的重新渲染看作是一次纯函数的作用过程。在此过程中引发的
   Flux架构之外的事物的变化,比如地图框架中的图层操作则属于该纯函数中的'副作用'。
   以地图类型的应用为例:地图应用中充斥着大量的"副作用",在这样的应用类型中,使用React作为前
   端UI库,就需要处理好应用的状态与地图框架副作用的'同步'[React Doc - You Might Not Need an Effect](https://beta.reactjs.org/learn/you-might-not-need-an-effect),即
   组件状态中的图层列表(数据)与图层添加/删除,顺序变换,显示与隐藏...等等交互需求所对应的地
   图/图层对象的操作
2. **复杂的交互场景下,前端组件内部不同状态的响应式变化:每次状态变化都需要触发另外组件中某个状态的变化。**
   这种场景是将某个组件(A)的状态的变化和对应的重新渲染看作一次纯函数的作用过程。在此过程中
   引发的另一个组件(B)的状态的变化和重新渲染则属于该纯函数过程中的'副作用'。
   以面板折叠/展开场景为例
   此场景通常出现在UI交互需求中,面板A 展开时 面板B需要收起,但是有多个交互操作(DOM事件回
   调)会触发面板A折叠与展开的状态的变动, 如果使用RCC实现,那么每次调用setState的时候都需要
   编写收起面板B的回调(此次操作的'副作用')

回归到副作用代码的编写: 在RCC中,开发者想要将React的state变动与其副作用同步时,就简单的在每次setState之后执行相关的副作用。类组件的范式让开发者在编写逻辑的时候不容易想起副作用这一函数式编程概念,需要开发者自己去手动的将'副作用'的操作与setState这一改变视图状态的操作进行同步。随着web应用设计开发过程中不断升级,前端组件的组合结构日渐复杂,一个组件将持有非常多的状态,每次对状态的变动都会牵扯到副作用的同步(业务逻辑代码的编写),刚开始编写这些代码的时候可能很流畅,但是后期维护迭代的时候就会惊讶的发现:"为什么这个逻辑的代码到处都是!",你或许会想出一个好点子:"我把这些逻辑代码封装一下呀,每个setState的地方粘贴一下就好了",OK,在这个时候你便会恍然大悟,"我自己将副作用作为一个个完整的模块,从此state的变化就是state的变化,副作用就是副作用,再也不用刻意的将setState与逻辑代码揉在一起写了",所以一个个隐式的useEffect诞生了。

RFC的useEffect直接将状态变动相关联的副作用以显式的代码组织方式帮助开发者将状态改变与副作用的分离,让开发者编写代码的时候,不用一边思考状态变化一边思考如何同步副作用,用户可以在写逻辑代码的时候专心逻辑不去考虑副作用与状态的同步,在useEffect的hook中去与专心编写副作用。帮助开发者做到了状态改变和状态关联的副作用的关注点分离,将'数据驱动'的机制发挥的更彻底,不仅数据驱动了视图,数据的变动还驱动了行为(状态变动驱动副作用)

## "状态"这一机制的实现方式由 利用面向对象中实例的属性 变为 JS与生俱来的"闭包"机制
函数式的思想在React的组件实现层面彻底实现,v = f(state)不仅仅"react更新视图的机制"体现了这一纯函数,组件内部的状态机制的实现方式由"面向对象的属性管理"转为"函数的闭包",使用RFC之前,React纯函数思想体现在WebAPP渲染机制这一宏观视角上,使用RFC之后,React的组件这一微观尺度上也体现了他的纯函数思想。
TODO这里需要对React的诞生和RFC的诞生做考古工作。

TODO
JS Conf react 创始人表述的react思想,
React函数式组件考古