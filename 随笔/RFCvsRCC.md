# RFC vs RCC(React Function Component VS React Class Component)

> 函数式组件与类组件究竟哪里不同? 函数式组件的出现帮助开发者解决了什么问题?
> 这是我从入职前端开始用react,查看React文档后看到了RFC RCC两种组件的写法就思考的问题,
> 网上的那些浅尝辄止的回答,真的太愚蠢了!!!

## 实践中的启发

> 工作时一直在实践中思考这个问题,在积累了一段时间后受下述场景的启发,逐渐对这个问题有了
> 自己的阶段性理解,

1. **webgis地图应用的前端实践,即React Flux架构下的应用状态与第三方库的副作用的复杂同步的场景下RFC vs RCC**。
   这种场景是将React的状态变更和对应的重新渲染看作是一次纯函数的作用过程。在此过程中引发的
   Flux架构之外的事物的变化,比如地图框架中的图层操作则属于该纯函数中的'副作用'。
   以地图类型的应用为例:地图应用中充斥着大量的"副作用",在这样的应用类型中,使用React作为前
   端UI库,就需要处理好应用的状态与地图框架副作用的'同步'[React Doc - You Might Not Need an Effect](https://beta.reactjs.org/learn/you-might-not-need-an-effect),即
   组件状态中的图层列表(数据)与图层添加/删除,顺序变换,显示与隐藏...等等交互需求所对应的地
   图/图层对象的操作
2. **复杂的交互场景下,前端组件内部不同状态的响应式变化:每次状态变化都需要触发另外组件中某个状态的变化。**
   这种场景是将某个组件(A)的状态的变化和对应的重新渲染看作一次纯函数的作用过程。在此过程中
   引发的另一个组件(B)的状态的变化和重新渲染则属于该纯函数过程中的'副作用'。
   以面板折叠/展开场景为例
   此场景通常出现在UI交互需求中,面板A 展开时 面板B需要收起,但是有多个交互操作(DOM事件回
   调)会触发面板A折叠与展开的状态的变动, 如果使用RCC实现,那么每次调用setState的时候都需要
   编写收起面板B的回调(此次操作的'副作用')
对函数式的组件的认识也经历了发展: 不知道这样搞干嘛,在地图框架的使用中逐渐理解了副作用,复杂
交互的实现过程中进一步扩展了自己对副作用的认识,重复写副作用的过程中,体会到了函数式组件给开发
者带来的便利, 问题的核心就在"副作用" 在"Flux" 在"FP",那为什么一开始要用类组件呢,这就要参考
JS Conf react 创始人所讲的react思想

但是再进一步思考一下,RFC相较于RCC 有什么特点呢?

回归到副作用代码的编写: 在RCC中,开发者想要将React的state变动与其副作用同步时,就简单的在每次setState之后执行相关的副作用。副作用这一函数式编程概念没有在编写逻辑的时候直接暴露给开发者,需要开发者自己去手动的将'副作用'的操作与setState这一改变视图状态的操作进行同步。随着web应用设计开发过程中不断升级,前端组件的组合结构日渐复杂,一个组件将持有非常多的状态,每次对状态的变动都会牵扯到副作用的同步(业务逻辑代码的编写),编写这些代码的时候可能很流畅,但是后期维护迭代的时候就会惊讶的发现:"为什么这个逻辑的代码到处都是!",你或许会想出一个好点子:"我把这些逻辑代码封装一下呀,每个setState的地方粘贴一下就好了",OK,在这个时候你便会恍然大悟,"我自己将副作用作为一个个完整的模块,从此state的变化就是state的变化,副作用就是副作用,再也不用刻意的将setState与逻辑代码揉在一起写了",所以一个个隐式的useEffect诞生了。

TODO
参考JS Conf react 创始人所讲的react思想,React函数式组件设计之初是为了解决什么问题呢或者实现了什么样的设计思想?
如今React类组件面对的问题是什么呢?

那么我们可以发现状态变动有其对应的副作用,RFC的useEffect直接将状态变动相关联的副作用以响应式的显式的代码组织方式帮助用户强化状态与副作用的分离,让开发者编写代码的时候,不用一边思考状态变化一边思考如何同步副作用,用户可以在写逻辑代码的时候专心逻辑不去考虑副作用与状态的同步,在useEffect的hook中去与专心编写副作用。

行文至此,我发现我需要将RFC VS RCC的文章标题改为RFC Hooks' work,也不是 我发现我的关注点错了,我的关注点不应该是为什么要发明RFC,我的关注点应该是RFC与RCC给开发者带来怎么样不同的体验和机制,至于为什么发明,那是另一个专题,我可以去追踪React小组的信息来解决这个问题

```js
useEffect(()=>{
   //do the effect when the xxxState change
},[xxxState])
```

帮助开发者做到了状态改变和状态关联的副作用的关注点分离,将'数据驱动'的机制发挥的更彻底,不仅数据驱动了视图,数据的变动还驱动了行为(状态变动驱动副作用)
