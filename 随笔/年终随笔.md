
# 2023/1/19

## 年终随笔

## 现实

## 项目经历

1. 影像数据生产任务监控、分发、管理系统-DMES(Data MES,数据生产MES系统)的重构和更新.
   项目周期即贡献:
   第一阶段:代码架构调整。
   参与前端的基础设施的技术选型,参与新版本前端代码架构设计
   第二阶段:业务逻辑实现与更新。
   按照新版本代码架构重新封装API层代码,规范组件名称,将组件式路由调整为递归函数生成的配置式路由。
   将旧版本的代码填充至新版本架构中。
   第三阶段测试与交付:
   修复Bug, 更新交互, 优化性能

   项目难点:

   1. 权限系统设计即权限系统前后端耦合:
      > 前端建立Purview权限的数据模型(类),用户首次登录时将用户的总权限值,与后端的权限码保持一致,在需要权限控制的交互/路由节点,增加权限控制,限制用户的UI和交互。
      > 单层权限无法满足需求后设计了多层权限,提出了"域"的概念,即将用户当前所在的路由位置映射为"系统"、"团队"、"项目"三个系统级别,不同域内权限列表不同,用户在三级域中有不同的权限系统,通过权限系统的分级实现更细致的权限控制。
      > 前端的配合手段就是利用sessionStorage存放用户当前的域,用户所在域变动时, 更新域, 发送请求时将域放入请求头, 与后端相配合

   2. 根据后端的JSON生成表单,动态的表单项,动态的校验规则:
      > 二次封装Form.Item组件,根据JSON递归生成Form.Item,

2. 遥感影像轻型检索系统
   遥感影像检索、浏览、管理系统
   项目周期即贡献:
   技术选型: 脚手架:customize-cra + react-app-rewired + cra 
            地图框架:leaflet
            UI框架: antd react
            状态管理工具: dva
   全程独立开发,封装leaflet图层组件,完全由数据驱动的图层组件,原理:灵活运用react Class Component的生命周期,通过组件组合的方式来完成图层加载这一副作用和react状态的同步
   项目难点:
   1. 遥感影像数据模型(业务模型),中类型tif数据或者其他传统遥感数据中的元数据(metaData)
   的概念的理解。
   2. 地图库如Leaflet和react库配合使用时, 对"副作用" ,生命周期函数, 以及RFC hooks的理解有一定的要求。
   3. google:xyz形式的地图服务,OGC标准的wmts,wms,wfs地图服务添加图层之前的预处理:要根据后端返回的元信息,来判断这个地理数据是以什么样的地图服务来添加到图层中,解析wmts,wms地图服务
3. 地理大数据仓库管理平台,负责数据浏览模块。
   项目周期即贡献:

### 未完成

Flux架构到redux实践的历史沿革,
深入理解前端工程化
深入理解前端模块化(history and why and future)
js设计模式

### Inspiration

在回忆项目经历的时候有一种感觉: 作为产品研发团队的前端开发, 对于系统和业务产生思考之后,不禁会产生对于系统设计的疑问:

1. "系统设计真的合理吗,扩展性强吗?"

2. "这样的频繁改动设计的工作模式,前端的每次扩展或者更新进行起来是让人心神具疲?"

但是团队的重心往往都在后端,后端团队对业务进行抽象后提供数据操作接口,前端来实现视图和交互。往往这样一种开发体验: 前端已经做好了一个版本,建立了一些前端自己使用的数据模型和数据流,但是"与业务逻辑耦合的交互逻辑"实现后,整个小组发现这样的设计存在种种缺陷,不得不改动设计,但是系统设计变动(一定程度上)对后端代码结构的"破坏"应该远远没有其对前端数据模型和数据流方案的"破坏"来的严重。
造成这种"前端代码迭代困难,维护困难"的根本原因我认为就是:
   1. 前端的组件的实现与业务模型解耦没有做好。
   假设视图为v,数据为state,react render为f,那么有纯函数v = f(state) (1)。
   副作用函数CurState = sideEffect(preState,event) (2)
   (1)任何时候都为纯函数,但是一旦涉及到数据库操作那么
   v = f(sideEffect(preState,event)) (3)
   f_sideEffect(preState,event) = f(sideEffect(preState,evnet)) (4)
   v = f_sideEffect(preState,event) (5)
   很明显这个不是纯函数了,不同时间输入相同的preState,event可能会有不同的v, 
   但是v是react和浏览器来负责的,他们不会觉得不舒服,他们只是程序只管一遍一遍的实现v = f(state)

   做个推广和归纳
   前端组件的代码为CompomentCode
   CompomentCode = KeyboardAndBrain(uIDesign + dataFlow) (6)
   假设KeyboardAndBrain = foo(someone)是纯函数
   那么根据(6), uIDesign与dataFlow每一次变动,组件的代码都要改一次
   耦合与抽象是天秤的两端,耦合太重一般归因于抽象不到位,我们在写"业务逻辑组件"的时候,即由业务模型对应的数据和交互设计,抽象出核心状态,去后端提供的接口的数据中拿数据来作为状态数据,编写组件代码,设计一改,那么状态就要变动,组件代码必然要发生变动。因为状态,交互,视图 三个是耦合的!!!。**UI设计**决定了前端开发要用后端数据模型中的什么数据来建立"组件"这个 v = React.render(state) 中的state；**交互设计**决定了前端发请求的写法,前端拼接数据的写法,可以抽象为伴随用户交互而发生的 curState = sideEffect(preState,event)副作用的写法,前端组合组件的组合方式。
   组件与业务逻辑和数据模型进行了绑定,每变动一次,都对组件做一次小的摧毁,最终状态混乱,数据流出现漏洞,维护困难,因为开发者无法弄清楚"当初这个组件/页面的数据流为什么这样设计,为什么这个数据流与现在的设计格格不入,当初的状态和组件设计不能实现现在的交互了"。
   为什么难以维护呢?就是因为封装业务逻辑的组件的时候抽象程度太低:
   举个例子: 图层列表组件,本质是对象列表,那么核心抽象是"列表组件",将图层也作为一个抽象封装到这个组件中,一旦"图层"抽象做不好,比如没有考虑到图层的服务类型,图层用什么地图框架等等,那么图层交互的设计一经改变,图层列表的组件里面的一些状态设计就要改变,一次两次还好,可以采用打补丁的模式去添加状态添加逻辑代码,次数多了就不得不重写了。因为抽象不到位,必定导致从用户交互到请求参数拼接这整条代码线的耦合,一处改动,处处改动。
   状态,交互,视图 对应React组件 中的 state,逻辑代码(各种交互的回调和处理数据的function),jsx。
   应该让state与逻辑代码高度内聚, 他俩组成的整体与jsx解耦, 如何将jsx与状态和逻辑解耦呢? 那就是封装组件的时候,只负责将dom交互的回调和一些抽象的逻辑以函数的形式暴露给父组件(使用它的组件),组件只负责将发生的用户交互暴露给使用者,而不自己实现某个交互去做什么事情,这样自己封装的组件就变成了一个事件监听和发布器,只负责将用户的交互传递给其他组件,由上层组件决定什么样的交互对应如何操作state如何驱动视图变化。
   那怎么办: 应该将业务的逻辑,和抽象的组件分离。列表就是列表,只负责对数据模型的UI渲染与用户交互的回调函数的暴露("用户点击某一行数据"这个行为中的"点击"和"点击的这一行数据"暴露出去),业务的逻辑由父组件实现,防止相关的状态要跨组件共享,以图层列表为例,如果图层逻辑都在图层列表里,那么图层列表的兄弟组件要用到图层列表里的状态怎么办,兄弟组件要改变图层列表的状态怎么办?不要等到后期,改交互了,然后再进行状态提升,再去考虑把状态抽到Dva里面去,那个时候代码就混乱不堪,会出现一种情况:"有部分状态在组件内部,还有部分状态在dva和父组件里面",这样等于没有做任何封装,甚至比做了封装还要恐怖,比封装少了内聚,比不封装多了耦合程度。react核心模式数据驱动视图,视图通过交互来驱动数据的变化再进一步驱动视图变化,要人为做到将组件的交互做到最抽象,暴露足够的信息给回调函数,让可以灵活修改的回调函数来负责逻辑,以图层列表为例,对图层列表这个组件进行交互,那应当只暴露交互的那个DOM对应的数据是什么,用户是做的什么交互。然后在一个回调函数中集中处理这个交互"要做什么"(一般是拼接参数发送请求,或者是单纯的改变组件的UI状态),这样设计变动的时候只要去改特定地方的代码,不用到处找代码
   2. ~~产品设计流程有点问题,甚至开发走在设计前面。(我现在还没有资格讨论这一方向)~~

组件重构带来的心智负担,决定了前端工作的痛苦程度。

很显然,在前端天生弱势并且我个人大型工程经验不足的情况下,从干预设计的角度去解决迭代问题是不可能的,不如从自己前端的设计思路上优化自己,适应团队。